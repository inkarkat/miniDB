#!/bin/bash

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-s|--schema "KEY COL1 [COL2 ...]"] [-n|--namespace NAMESPACE] -t|--table TABLE [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -u|--update RECORD'
    #printf 'Usage: %q %s\n' "$(basename "$1")" '... -d|--delete KEY'
    #printf 'Usage: %q %s\n' "$(basename "$1")" '... -D|--drop'
    #printf 'Usage: %q %s\n' "$(basename "$1")" '... -e|--each COMMAND'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -q|--query KEY [-f|--fallback FALLBACK-KEY] [-c|--columns *|COL1 [...]|N [...]] [--as-escaped-lines]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Records and retrieves individual LINEs based on a single KEY lookup inside a
TABLE [within NAMESPACE], using simple tab-separated data files as storage.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --schema|-s "KEY COL1 [...]"Optional database schema; will be included as a
				commented first line in the data file.
    --namespace|-n NAMESPACE	Optional application / use case for this tool's
				use. Determines the configuration directory.
    --table|-t TABLE		Category in the context of the application.
				Determines the configuration file.
    --update|-u RECORD		Record RECORD, which must consist of a KEY + tab
				+ optional additional columns. An existing
				record with the same KEY is overwritten, else it
				is appended.
    --query|-q KEY		Query whether a record for KEY exists and return
				it.
    --fallback|-f FALLBACK-KEY
				Lookup FALLBACK-KEY instead if KEY hasn't been
				recorded.
    --columns|-c		Instead of returning the entire record, just
				return:
				* non-key columns
				COL1 [...] columns that match the passed schema
					   (in the order given)
				N [...]	   columns with the passed indices,
					   starting with 0 for KEY, 1 for COL1
    --as-escaped-lines		Instead of returning the record in the original
				format, return each column as a separate line.
				Newlines and backslashes contained within a
				column will be escaped as \\n and \\\\,
				respectively, so that newlines don't interfere
				with the line structure and parsing.
EXIT STATUS:
    0	Complete success.
    1	Failed to read / write the table file.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	The queried KEY (nor FALLBACK-KEY if given) does not exist.

Example:
HELPTEXT
printf '%q %s\n' "$(basename "$1")" '--schema "WINDOWID TIMESTAMP" --table creationTimes --update "$WINDOWID	$(date +%s)"'
printf '%q %s\n' "$(basename "$1")" '--table creationTimes --query 123456'
}

containsTab()
{
    [[ "${1?}" =~ $'\t' ]]
}
multipleActionsError()
{
    echo >&2 "ERROR: Only one of --update, --query allowed."
    echo >&2
    printShortUsage "$1" >&2
    exit 2
}
typeset -a schema=(KEY COLUMN ...)
namespace=
table=
line=
key=
fallbackKey=
action=
typeset -a queriedColumns=()
isOmitKey=
isAsEscapedLines=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--schema|-s)	shift; schema=($1); shift
			if [ ${#schema[@]} -eq 0 ]; then
			    echo >&2 'ERROR: No schema passed.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			;;
	--namespace|-n)	shift; namespace="$1"; shift;;
	--table|-t)	shift; table="$1"; shift;;
	--fallback|-f)	shift; fallbackKey="$1"; shift;;
	--update|-u)	shift; [ "$action" ] && multipleActionsError "$0"; action='update'; line="$1"; shift
			containsTab "$line" || line="${line}$'\t'"   # Need at least one tab separator.
			;;
	--query|-q)	shift; [ "$action" ] && multipleActionsError "$0"; action='query'; key="$1"; shift
			if containsTab "$key"; then
			    echo >&2 'ERROR: KEY cannot contain tab characters.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			;;
	--columns|-c)	shift
			if [ "$1" = '*' ]; then
			    isOmitKey=t
			else
			    queriedColumns=($1)
			    if [ ${#queriedColumns[@]} -eq 0 ]; then
				echo >&2 'ERROR: No columns passed.'
				echo >&2
				printShortUsage "$0" >&2
				exit 2
			    fi
			fi
			shift
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -gt 0 ]; then
    printShortUsage "$0" >&2
    exit 2
elif [ ! "$action" ]; then
    echo >&2 "ERROR: No action passed."
    echo >&2
    printShortUsage "$0" >&2
    exit 2
elif [ ! "$table" ]; then
    echo >&2 'ERROR: No TABLE passed.'
    echo >&2
    printShortUsage "$0" >&2
    exit 2
fi


literalPattern()
{
    sed -e 's/[][\$*.^/]/\\&/g'
}
escapeNewline()
{
    sed ':a; s/\\/\\\\/g; x; G; 1s/\n//; s/\n/\\n/; h; N; s/.*\n//; ta' <<<"${1:?}"
}

query()
{
    [ -e "$TABLE_FILESPEC" ] || return 1

    # Escape newlines and backslashes.
    [ "${key/[$'\n'\\]/}" = "$key" ] || key="$(escapeNewline "$key")"
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    if [ "$fallbackKey" ]; then
	# Get the $key line, with fallback to $fallbackKey
	[ "${fallbackKey/[$'\n'\\]/}" = "$fallbackKey" ] || fallbackKey="$(escapeNewline "$fallbackKey")"
	local literalFallbackPattern="$(printf %s "$fallbackKey" | literalPattern)"
	local line="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t\\|^${literalFallbackPattern}\\t/H" -e "\${ g; s/^\\n//; s/^${literalFallbackPattern}\\t.*\\n//; s/\\n${literalFallbackPattern}\\t.*\$//; /./p }" -e ':skipHeader' "$TABLE_FILESPEC")"
    else
	local line="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t/p" -e ':skipHeader' "$TABLE_FILESPEC")"
    fi
    [ "$line" ] || return 4

    if [ "$isOmitKey" ]; then
	line="${line#*$'\t'}"
    elif [ ${#queriedColumns[@]} -gt 0 ]; then
	local IFS=$'\t'
	typeset -a columns=($line)
	local newLine=
	local separator=
	for c in "${queriedColumns[@]}"
	do
	    newLine="${newLine}${separator}${columns[$c]}"
	    separator=$'\t'
	done
	line="$newLine"
    fi

    echo -e "${line/#-/\\x2d}"
}

initializeTable()
{
    local IFS=$'\t'
    printf > "$TABLE_FILESPEC" '# %s\n' "${schema[*]}"
}
update()
{
    [ -r "$TABLE_FILESPEC" ] || initializeTable  # Need to write at least one line so that sed does processing; can use that for a descriptive header.

    # Escape newlines and backslashes.
    [ "${line/[$'\n'\\]/}" = "$line" ] || line="$(escapeNewline "$line")"

    local key="${line%%$'\t'*}"
    if [ ! "$key" ]; then
	echo >&2 'ERROR: Key must not be empty.'
	exit 2
    fi
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that we don't need to append the line at the end.
    # On the last line, we check the hold space, and skip further processing of
    # the line if the hold space isn't empty.
    sed -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/h" \
	-e "/^${literalKeyPattern}\\t/c${line//\\/\\\\}"  \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e "\$a${line//\\/\\\\}" \
	"$TABLE_FILESPEC" || return 1
}

typeset -a IGNORE_HEADER_LINE_SED_ARGS=(-e '1{ /^#/b skipHeader }')

readonly CONFIG_DIRSPEC="${XDG_CONFIG_HOME:-$HOME/.config}${namespace:+/}$namespace"
[ -d "$CONFIG_DIRSPEC" ] || mkdir -p -- "$CONFIG_DIRSPEC" || { printf >&2 'ERROR: Could not initialize database store at %s!\n' "$CONFIG_DIRSPEC"; exit 1; }
readonly TABLE_FILESPEC="${CONFIG_DIRSPEC}/$table"

"$action"
