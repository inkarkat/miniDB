#!/bin/bash
###############################################################################
##
# FILE:		miniDB
# PRODUCT:	tools
# AUTHOR:	Ingo Karkat <ingo@karkat.de>
# DATE CREATED:	04-Apr-2019
#
###############################################################################
# CONTENTS:
#   A lightweight file-based columnar database supporting CRUD operations with a
#   single lookup key.
#
# REMARKS:
#
# @(#)miniDB	$Id$	tools
###############################################################################
set -o noglob
shopt -qs extglob

baseDir="${XDG_CONFIG_HOME:-$HOME/.config}"
printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--basedir DIR|--base-type config|data|runtime|cache] [-s|--schema "KEY COL1 [COL2 ...]"] [-n|--namespace NAMESPACE] -t|--table TABLE [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... (--start-read-transaction OWNER-ID [--transaction-timeout TX-TIMEOUT]|--start-write-transaction OWNER-ID [--transaction-timeout TX-TIMEOUT]|--upgrade-to-write-transaction OWNER-ID [--transaction-timeout TX-TIMEOUT]|--end-transaction OWNER-ID|--abort-write-transaction OWNER-ID) [--timeout SECONDS] [--silence-transaction-errors]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [(-t|--transactional|--within-transaction) [--timeout SECONDS] [--transaction-timeout TX-TIMEOUT]] ...'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -u|--update RECORD'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -d|--delete KEY'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -D|--drop'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -e|--each "COMMANDLINE" [-e|--each ...] [--before "COMMANDLINE" [--before ...]] [--after "COMMANDLINE" [--after ...]]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -q|--query KEY [-f|--fallback FALLBACK-KEY] [-c|--columns *|COL1 [...]|N [...]] [--as-escaped-lines|--as-shell-variables]'
    printf 'Usage: %q -x|--unescape "$(%q %s)"\n' "$(basename "$1")" "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-escaped-lines'
    printf 'Usage: eval "$(%q %s)"\n' "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-shell-variables'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -k|--query-keys'
    printf 'Usage: %q %s | %q -x|--unescape [-]\n' "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-escaped-lines' "$(basename "$1")"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Records and retrieves individual LINEs based on a single KEY lookup inside a
TABLE [within NAMESPACE], using simple tab-separated data files as storage.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --basedir DIR		Set the base directory in which the NAMESPACE
				dir / TABLE file is stored. Defaults to
				XDG_CONFIG_HOME=$baseDir.
    --base-type config|data|runtime|cache
				Set the base directory based on the passed
				characterization. The default is "config".
    --schema|-s "KEY COL1 [...]"Optional database schema; will be included as a
				commented first line in the data file.
    --namespace|-n NAMESPACE	Optional application / use case for this tool's
				use. Determines the configuration directory.
    --table|-t TABLE		Category in the context of the application.
				Determines the configuration file.
    --update|-u RECORD		Record RECORD, which must consist of a KEY + tab
				+ optional additional columns. An existing
				record with the same KEY is overwritten, else it
				is appended.
    --delete|-d KEY		Delete any existing record for KEY.
    --drop|-D			Completely wipe all records and the table
				configuration file itself.
    --query|-q KEY		Query whether a record for KEY exists and return
				it.
    --fallback|-f FALLBACK-KEY
				Lookup FALLBACK-KEY instead if KEY hasn't been
				recorded.
    --columns|-c		Instead of returning the entire record, just
				return:
				* non-key columns
				COL1 [...] columns that match the passed schema
					   (in the order given)
				N [...]	   columns with the passed indices,
					   starting with 0 for KEY, 1 for COL1
    --as-escaped-lines		Instead of returning the record in the original
				format, return each column as a separate line.
				Newlines and backslashes contained within a
				column will be escaped as \\n and \\\\,
				respectively, so that newlines don't interfere
				with the line structure and parsing.
    --as-escaped-lines		Instead of returning the record in the original
				format, return each column as a separate shell
				variable, named after the schema (or COL0, COL1,
				... if no schema is passed nor defined on the
				table). The output is expected to be eval'd to
				define the variables.
    --unescape|-x OUTPUT|[-]	Interpret escaped backslashes and newlines from
				a query with --as-escaped-lines into the
				original text (of a single column; you could
				pass multiple columns, but then the column
				borders would be lost).
    --query-keys|-k		List all available keys.
    --each COMMANDLINE		Invoke COMMANDLINE once for each record. Values
				for the current record's columns are available
				in shell variables that correspond to the
				table's schema. If you didn't define a schema on
				table creation you can refer to columns via the
				COL array (KEY is 0), or explicitly provide one
				via --schema now.
				If there are multiple COMMANDLINEs, each will be
				a separate pass over the table.
    --before COMMANDLINE	Execute COMMANDLINE before any iteration; this
				can be used to initialize some variables used
				within the iteration.
    --after COMMANDLINE		Execute COMMANDLINE after all iterations; this
				can be used to use accumulated iteration
				results.
TRANSACTIONS:
    --transactional|-t		Lock TABLE during the access so that writes are
				serialized and concurrent reads can only happen
				while no write is under way. Pass this to ensure
				consistency in case there could ever be
				contention over the file.
    --timeout SECONDS		Fail if the lock to check for / start a
				transaction cannot be acquired within SECONDS
				(instead of waiting indefinitely) (because
				another transaction is still active).
				0 means fail rather than wait if the lock cannot
				be acquired immediately.
    --silence-transaction-errors
				Don't print transaction-related errors (but keep
				printing warnings). This can be used if a
				fallback action is implemented, e.g.
    if ! miniDB --upgrade-to-write-transaction "\$\$"; then
	miniDB --silence-transaction-errors --end-transaction "\$\$"
	miniDB --silence-transaction-errors --start-write-transaction "\$\$" &&
	    value="\$(miniDB --within-transaction "\$\$" --query ...)"
    fi
    --start-read-transaction OWNER-ID
				Start a transaction that does not modify TABLE.
				Until --end-transaction (or TX-TIMEOUT), no
				other updates to the TABLE are possible.
    --start-write-transaction OWNER-ID
				Start a transaction that modifies TABLE.
				Until --end-transaction (or TX-TIMEOUT), no
				other reads or updates to the TABLE are
				possible.
    --upgrade-to-write-transaction OWNER-ID
				Change a held transaction that was started with
				--start-read-transaction (and hasn't become
				shared) to also allow modifications of TABLE.
				Until --end-transaction (or TX-TIMEOUT, which is
				extended), no other reads or updates to the
				TABLE are possible.
    --transaction-timeout TX-TIMEOUT
				A transition is automatically aborted if more
				than TX-TIMEOUT (default 3) seconds passed since
				--start-*-transaction.
    --within-transaction OWNER-ID
				Perform an action within the transaction.
    --end-transaction OWNER-ID
				End the transaction, so that other clients can
				do updates again. If this does not happen within
				TX-TIMEOUT, another transaction may be started
				and aborts this one.
    --abort-write-transaction OWNER-ID
				End the transaction, and undo any writes done
				within it.
EXIT STATUS:
    0	Complete success.
    1	Failed to read / write / remove the table file.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	The queried KEY (nor FALLBACK-KEY if given) / to-be-deleted key does not
	exist.
    5	Time out while waiting to start a transaction.
    6	The current transaction has taken too long (TX-TIMEOUT). On
	modifications --within-transaction, aborts. On --end-transaction, if it
	was pre-empted by another one, any updates have been lost.

Example:
HELPTEXT
printf '%q %s\n' "$(basename "$1")" '--schema "WINDOWID TIMESTAMP" --table creationTimes --update "$WINDOWID	$(date +%s)"'
printf '%q %s\n' "$(basename "$1")" '--table creationTimes --query 123456'
printf '\nTransactional Example:\n'
printf '%q %s\n' "$(basename "$1")" '--start-read-transaction "$$" --table creationTimes'
printf '%q %s\n' "$(basename "$1")" '--within-transaction "$$" --table creationTimes --query 123456'
printf '%q %s\n' "$(basename "$1")" '--upgrade-to-write-transaction "$$" --table creationTimes'
printf '%q %s\n' "$(basename "$1")" '--within-transaction "$$" --table creationTimes --delete 123456'
printf '%q %s\n' "$(basename "$1")" '--end-transaction "$$" --table creationTimes'
printf 'or:\n'
printf '%q %s\n' "$(basename "$1")" '--transactional --table creationTimes --query 123456'
}

containsTab()
{
    [[ "${1?}" =~ $'\t' ]]
}
multipleActionsError()
{
    echo >&2 "ERROR: Only one of --update, --delete, --drop, --each, --query[-keys], --unescape, --start-read-transaction, --start-write-transaction, --upgrade-to-write-transaction, --within-transaction, --end-transaction, --abort-write-transaction allowed."
    echo >&2
    printShortUsage "$1" >&2
    exit 2
}
multipleTransactionsError()
{
    echo >&2 "ERROR: --transactional cannot be combined with the --start-read-transaction|--start-write-transaction|--upgrade-to-write-transaction|--within-transaction|--end-transaction|--abort-write-transaction set, and only one from the set can be given."
    echo >&2
    printShortUsage "$1" >&2
    exit 2
}
needReadLock=
transactionOwner=
waitTimeout=
transactionTimeout=3
readonly DEFAULT_SCHEMA='KEY COLUMN ...'
typeset -a schema=()
typeset -a normalizedSchema=()
namespace=
table=
line=
key=
fallbackKey=
preAction=
action=
postAction=
typeset -a queriedColumns=()
isOmitKey=
outputFormat=
typeset -a commandLines=()
typeset -a beforeCommands=()
typeset -a afterCommands=()
typeset -a miniTxArgs=()
isSilenceTransactionErrors=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--basedir)	shift; baseDir="$1"; shift;;
	--base-type)	shift
			case "$1" in
			    config)	baseDir="${XDG_CONFIG_HOME:-$HOME/.config}";;
			    data)	baseDir="${XDG_DATA_HOME:-$HOME/.local/share}";;
			    runtime)	baseDir="${XDG_RUNTIME_DIR:-/run/user/$UID}";;
			    cache)	baseDir="${XDG_CACHE_HOME:-$HOME/.cache}";;
			    *)		printf >&2 'ERROR: Invalid base-type "%s".\n' "$1"
					echo >&2
					printShortUsage "$0" >&2
					exit 2
					;;
			esac
			shift
			;;
	--transactional|-t)		shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; preAction='startTransaction'; postAction='endTransaction'; transactionOwner="$$";;
	--within-transaction)		shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; preAction='checkTransaction'; transactionOwner="$1"; shift;;
	--start-read-transaction)	shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; [ "$action" ] && multipleActionsError "$0"; action='startTransaction'; needReadLock=t; transactionOwner="$1"; shift;;
	--start-write-transaction)	shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; [ "$action" ] && multipleActionsError "$0"; action='startTransaction'; transactionOwner="$1"; shift;;
	--upgrade-to-write-transaction)	shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; [ "$action" ] && multipleActionsError "$0"; action='upgradeTransaction'; transactionOwner="$1"; shift;;
	--end-transaction)		shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; [ "$action" ] && multipleActionsError "$0"; action='endTransaction'; transactionOwner="$1"; shift;;
	--abort-write-transaction)	shift; [ "$transactionOwner" ] && multipleTransactionsError "$0"; [ "$action" ] && multipleActionsError "$0"; action='abortWriteTransaction'; transactionOwner="$1"; shift;;
	--timeout)			shift; waitTimeout="$1"; shift;;
	--silence-transaction-errors)	isSilenceTransactionErrors=t; miniTxArgs+=("$1"); shift;;
	--transaction-timeout)		shift; transactionTimeout="$1"; shift;;
	--schema|-s)	shift; schema=($1); shift
			if [ ${#schema[@]} -eq 0 ]; then
			    echo >&2 'ERROR: No schema passed.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			;;
	--namespace|-n)	shift; namespace="$1"; shift;;
	--table|-t)	shift; table="$1"; shift
			if [[ "$table" = */* ]]; then
			    echo >&2 'ERROR: TABLE must not contain slashes.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			;;
	--fallback|-f)	shift; fallbackKey="$1"; shift;;
	--update|-u)	shift; [ "$action" ] && multipleActionsError "$0"; action='update'; line="$1"; shift
			containsTab "$line" || line="${line}$'\t'"   # Need at least one tab separator.
			;;
	--delete|-d)	shift; [ "$action" ] && multipleActionsError "$0"; action='delete'; key="$1"; shift
			if containsTab "$key"; then
			    echo >&2 'ERROR: KEY cannot contain tab characters.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			elif [ ! "$key" ]; then
			    echo >&2 'ERROR: Key must not be empty.'
			    exit 2
			fi
			;;
	--drop|-D)	shift; [ "$action" ] && multipleActionsError "$0"; action='drop';;
	--query|-q)	shift; [ "$action" ] && multipleActionsError "$0"; action='query'; key="$1"; needReadLock=t; shift
			if containsTab "$key"; then
			    echo >&2 'ERROR: KEY cannot contain tab characters.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			elif [ ! "$key" ]; then
			    echo >&2 'ERROR: Key must not be empty.'
			    exit 2
			fi
			;;
	--query-keys|-k)
			shift; [ "$action" ] && multipleActionsError "$0"; action='queryKeys'; needReadLock=t;;
	--columns|-c)	shift
			if [ "$1" = '*' ]; then
			    isOmitKey=t
			else
			    queriedColumns=($1)
			    if [ ${#queriedColumns[@]} -eq 0 ]; then
				echo >&2 'ERROR: No columns passed.'
				echo >&2
				printShortUsage "$0" >&2
				exit 2
			    fi
			fi
			shift
			;;
	--as-escaped-lines)
			shift; outputFormat='escapedLines';;
	--as-shell-variables)
			shift; outputFormat='shellVariables';;
	--unescape|-x)	shift; [ "$action" ] && multipleActionsError "$0"; action='unescape'

			if [ $# -eq 0 -o "$1" = '-' ]; then
			    line="$(< /dev/stdin)"
			else
			    line="${1?}"
			fi
			shift
			table='dummy'	# Need to set this as it's mandatory for all other actions, but not used for unescape.
			;;
	--each|-e)	shift; [ "$action" -a "$action" != 'each' ] && multipleActionsError "$0"; action='each'; needReadLock=t; commandLines+=("$1"); shift;;
	--before)	shift; beforeCommands+=(${beforeCommands:+;} "$1"); shift;;
	--after)	shift; afterCommands+=(${afterCommands:+;} "$1"); shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -gt 0 ]; then
    printShortUsage "$0" >&2
    exit 2
elif [ ! "$action" ]; then
    echo >&2 "ERROR: No action passed."
    echo >&2
    printShortUsage "$0" >&2
    exit 2
elif [ ! "$table" ]; then
    echo >&2 'ERROR: No TABLE passed.'
    echo >&2
    printShortUsage "$0" >&2
    exit 2
fi
if [ "$action" = unescape ]; then
    # Need no transactions around unescaping.
    preAction=
    postAction=
fi


translateColumnNamesToIndices()
{
    # Translate any queried column names into the corresponding indices, using
    # the provided schema.

    typeset -A schemaToIndex=()
    for ((i = 0; i < ${#schema[@]}; i++))
    do
	schemaToIndex["${schema[$i]}"]="$i"
    done

    for ((i = 0; i < ${#queriedColumns[@]}; i++))
    do
	case "${queriedColumns[$i]}" in
	    +([0-9]))
		;;
	    *)
		index="${schemaToIndex["${queriedColumns[$i]}"]}"
		if [ "$index" ]; then
		    queriedColumns[$i]="$index"
		elif [ ${#schema[@]} -eq 0 ]; then
		    return 1
		else
		    printf >&2 'ERROR: Unknown column %s; not an index nor named in schema %s.\n' "${queriedColumns[$i]}" "${schema[*]}"
		    exit 2
		fi
		;;
	esac
    done
}
loadSchemaFromTable()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    local schemaLine="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e b -e ':skipHeader' -e 'p' -- "$TABLE_FILESPEC")"
    [ "$schemaLine" ] || return 1

    local IFS=' '; typeset -a defaultSchema=($DEFAULT_SCHEMA)
    local IFS=$'\t'; schema=(${schemaLine#\# })
    [ ${#schema[@]} -gt 0 -a "${schema[*]}" = "${defaultSchema[*]}" ] && schema=()
    [ ${#schema[@]} -gt 0 ]
}

literalPattern()
{
    sed -e 's/[][\$*.^/]/\\&/g'
}
escapeNewline()
{
    sed ':a; s/\\/\\\\/g; x; G; 1s/\n//; s/\n/\\n/; h; N; s/.*\n//; ta' <<<"${1:?}"
}
unescape()
{
    [ $# -ge 1 ] && line="$1"
    echo -e "${line/#-/\\x2d}"
}
normalizeSchema()
{
    normalizedSchema=("${schema[@]}")
    normalizedSchema=("${normalizedSchema[@]/#[^a-zA-Z_]/_}")
    normalizedSchema=("${normalizedSchema[@]//[^a-zA-Z0-9_]/_}")
}

query()
{
    local IFS=$'\t'
    [ -e "$TABLE_FILESPEC" ] || return 1

    # Escape newlines and backslashes.
    [ "${key/[$'\n'\\]/}" = "$key" ] || key="$(escapeNewline "$key")"
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    if [ "$fallbackKey" ]; then
	# Get the $key line, with fallback to $fallbackKey
	[ "${fallbackKey/[$'\n'\\]/}" = "$fallbackKey" ] || fallbackKey="$(escapeNewline "$fallbackKey")"
	local literalFallbackPattern="$(printf %s "$fallbackKey" | literalPattern)"
	local line="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t\\|^${literalFallbackPattern}\\t/H" -e "\${ g; s/^\\n//; s/^${literalFallbackPattern}\\t.*\\n//; s/\\n${literalFallbackPattern}\\t.*\$//; /./p }" -e ':skipHeader' -- "$TABLE_FILESPEC")"
    else
	local line="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t/p" -e ':skipHeader' -- "$TABLE_FILESPEC")"
    fi
    [ "$line" ] || return 4

    local fullLine="$line"
    if [ "$isOmitKey" ]; then
	line="${line#*$'\t'}"
    elif [ ${#queriedColumns[@]} -gt 0 ]; then
	typeset -a columns=($line)
	local newLine=
	local separator=
	for c in "${queriedColumns[@]}"
	do
	    newLine="${newLine}${separator}${columns[$c]}"
	    separator=$'\t'
	done
	line="$newLine"
    fi

    case "$outputFormat" in
	escapedLines)
	    typeset -a columns=($line)
	    printf '%s\n' "${columns[@]}"
	    ;;
	shellVariables)
	    if [ ${#queriedColumns[@]} -eq 0 ]; then
		typeset -a columns=($fullLine)
		if [ ${#schema[@]} -eq 0 ]; then
		    if ! loadSchemaFromTable; then
			local lastCol=$((${#columns[@]} - 1))
			eval "schema=({0..$lastCol})"
			schema=("${schema[@]/#/COL}")
		    fi
		fi
		local end=$((${#schema[@]} - 1))
		local start=0; [ "$isOmitKey" ] && start=1
		eval "queriedColumns=({$start..$end})"
	    fi

	    normalizeSchema
	    for c in "${queriedColumns[@]}"
	    do
		local value="$(unescape "${columns[$c]}x")"
		printf '%s=%q\n' "${normalizedSchema[$c]}" "${value%x}"
	    done
	    ;;
	'') unescape "$line";;
	*)  printf >&2 'ASSERT: Unknown outputFormat: %s\n' "$outputFormat"; exit 2;;
    esac
}

initializeTable()
{
    local IFS=' '; [ ${#schema[@]} -eq 0 ] && schema=($DEFAULT_SCHEMA)
    local IFS=$'\t'
    printf > "$TABLE_FILESPEC" '# %s\n' "${schema[*]}"
}
update()
{
    [ -r "$TABLE_FILESPEC" ] || initializeTable  # Need to write at least one line so that sed does processing; can use that for a descriptive header.

    # Escape newlines and backslashes.
    [ "${line/[$'\n'\\]/}" = "$line" ] || line="$(escapeNewline "$line")"

    local key="${line%%$'\t'*}"
    if [ ! "$key" ]; then
	echo >&2 'ERROR: Key must not be empty.'
	exit 2
    fi
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that we don't need to append the line at the end.
    # On the last line, we check the hold space, and skip further processing of
    # the line if the hold space isn't empty.
    sed -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/h" \
	-e "/^${literalKeyPattern}\\t/c\\
${line//\\/\\\\}"  \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e "\$a\\
${line//\\/\\\\}" \
	-- "$TABLE_FILESPEC" || return 1
}

delete()
{
    local IFS=$'\t'
    [ -e "$TABLE_FILESPEC" ] || return 1

    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that a deletion was done.
    # On the last line, we check the hold space, and indicate unsuccessful
    # deletion via a special exit status.
    sed -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/{ h; d; }" \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e '$q 4' \
	-- "$TABLE_FILESPEC"
}

drop()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    rm -- "$TABLE_FILESPEC"
}

iterateOverRecords()
{
    local commandLine="${1?}"; shift
    normalizeSchema

    while IFS=$'\t' read -r "$@" "${normalizedSchema[@]}"
    do
	eval "$commandLine"
    done < <(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e p -e ':skipHeader' -- "$TABLE_FILESPEC")
}
each()
{
    [ -e "$TABLE_FILESPEC" ] || return 1

    typeset -a iterateReadArgs=()
    if [ ${#schema[@]} -eq 0 ]; then
	if ! loadSchemaFromTable; then
	    iterateReadArgs=(-a COL)
	fi
    fi

    eval "${beforeCommands[@]}"
	for cl in "${commandLines[@]}"
	do
	    iterateOverRecords "$cl" "${iterateReadArgs[@]}"
	done
    eval "${afterCommands[@]}"
}
queryKeys()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    schema=(key ignoredColumns)
    iterateOverRecords 'echo $key'
}


lockedCall()
{
    local -r scriptDir="$([ "${BASH_SOURCE[0]}" ] && dirname -- "${BASH_SOURCE[0]}" || exit 3)"
    [ -d "$scriptDir" ] || { echo >&2 "ERROR: Cannot determine script directory!"; exit 3; }
    local method="${1:?}"; shift
    local mode=write; [ "$needReadLock" ] && mode=read
    flock "$@" --conflict-exit-code 5 ${waitTimeout:+--timeout "$waitTimeout"} "$LOCK_FILESPEC" "${scriptDir}/../lib/miniTX" "${miniTxArgs[@]}" "$method" "$TABLE_FILESPEC" "$LOCK_FILESPEC" "$transactionOwner" "$mode" "$transactionTimeout"
}
startTransaction()
{
    SECONDS=0
    local error
    while :
    do
	error="$(lockedCall TX-START)" || exit $?
	[ ! "$error" ] && break

	if [ -n "$NOW" -o \( -n "$waitTimeout" -a $SECONDS -ge ${waitTimeout:-0} \) ]; then
	    [ "$isSilenceTransactionErrors" ] || printf >&2 '%s\n' "$error"
	    exit 5
	fi

	sleep "${MINIDB_BLOCK_DELAY:-0.01s}"
    done
}
upgradeTransaction()
{
    lockedCall TX-UPGRADE
}
endTransaction()
{
    lockedCall TX-END
}
abortWriteTransaction()
{
    lockedCall TX-ABORT
}
checkTransaction()
{
    lockedCall TX-CHECK --shared
}



typeset -a IGNORE_HEADER_LINE_SED_ARGS=(-e '1{ /^#/b skipHeader }')

readonly CONFIG_DIRSPEC="${baseDir}${namespace:+/}$namespace"
[ -d "$CONFIG_DIRSPEC" ] || mkdir -p -- "$CONFIG_DIRSPEC" || { printf >&2 'ERROR: Could not initialize database store at %s!\n' "$CONFIG_DIRSPEC"; exit 1; }
readonly TABLE_FILESPEC="${CONFIG_DIRSPEC}/$table"
readonly LOCK_FILESPEC="${CONFIG_DIRSPEC}/.${table}.lock"

if [ ${#queriedColumns[@]} -gt 0 ]; then
    if ! translateColumnNamesToIndices; then
	if ! loadSchemaFromTable; then
	    printf >&2 'ERROR: Cannot resolve named columns from the table %s, as no schema is defined there. Use indices or pass a --schema SCHEMA.\n' "${namespace}${namespace:+/}${table}"
	    exit 2
	fi
	translateColumnNamesToIndices
    fi
fi

if [ "$preAction" ]; then
    "$preAction" || exit $?
fi
"$action"
status=$?
if [ "$postAction" ]; then
    "$postAction"
fi
exit $status
