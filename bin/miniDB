#!/bin/bash
###############################################################################
##
# FILE:		miniDB
# PRODUCT:	tools
# AUTHOR:	Ingo Karkat <ingo@karkat.de>
# DATE CREATED:	04-Apr-2019
#
###############################################################################
# CONTENTS:
#   A lightweight file-based columnar database supporting CRUD operations with a
#   single lookup key.
#
# REMARKS:
#
# @(#)miniDB	$Id$	tools
###############################################################################
set -o noglob
shopt -qs extglob

: ${MINIDB_COMMAND_JOINER=;}
: ${MINIDB_FILE_MARKER='{}'}
fileMarker="$MINIDB_FILE_MARKER"; unset MINIDB_FILE_MARKER
baseDir="${XDG_DATA_HOME:-$HOME/.local/share}"

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--basedir DIR|--base-type config|data|runtime|cache|temp] [-s|--schema "KEY COL1 [COL2 ...]"] [-n|--namespace NAMESPACE] -t|--table TABLE [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... (--start-read-transaction OWNER-ID [--transaction-timeout TX-TIMEOUT]|--start-write-transaction OWNER-ID [--transaction-timeout TX-TIMEOUT]|--upgrade-to-write-transaction OWNER-ID [--transaction-timeout TX-TIMEOUT]|--end-transaction OWNER-ID|--abort-write-transaction OWNER-ID) [--timeout SECONDS] [--silence-transaction-errors]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... [(-x|--transactional [--transaction-timeout TX-TIMEOUT]|--within-transaction|-X|--no-transaction) [--timeout SECONDS] [--silence-transaction-errors]] ...'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -u|--update RECORD [-c|--columns 0*|*|#|"COL1 [...]"|"N [...]" [--as-escaped-lines|--as-shell-variables]]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -u|--update KEY -v|--column COL1=VALUE1|N=VALUE-N|COL1++|N++ [-v|--column ...] [-c|--columns 0*|*|#|"COL1 [...]"|"N [...]" [--as-escaped-lines|--as-shell-variables]]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -d|--delete KEY'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -C|--truncate'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -D|--drop'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... --read-command "COMMANDLINE" [...]|--command "COMMANDLINE" [...] [--] SIMPLECOMMAND [...]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -e|--each "COMMANDLINE" [-e|--each ...] [--before "COMMANDLINE" [--before ...]] [--after "COMMANDLINE" [--after ...]]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '    ... -q|--query KEY [-f|--fallback FALLBACK-KEY] [-c|--columns *|"COL1 [...]"|"N [...]"] [--as-escaped-lines|--as-shell-variables]'
    printf 'Usage: %q -E|--unescape "$(%q %s)"\n' "$(basename "$1")" "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-escaped-lines'
    printf 'Usage: eval "$(%q %s)"\n' "$(basename "$1")" '-q|--query KEY -c|--columns "COL1 [...]"|"N [...]" --as-shell-variables'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -k|--query-keys'
    printf 'Usage: %q %s | %q -E|--unescape [-]\n' "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-escaped-lines' "$(basename "$1")"
    printf 'Usage: [DEBUG=%q:sed[!]] %q ...	DEBUG=%q:sed also prints it, DEBUG=%q:sed! just prints and skips execution\n' "$(basename "$1")" "$(basename "$1")" "$(basename "$1")" "$(basename "$1")"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Records and retrieves individual LINEs based on a single KEY lookup inside a
TABLE [within NAMESPACE], using simple tab-separated data files as storage.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --basedir DIR		Set the base directory in which the NAMESPACE
				dir / TABLE file is stored. Defaults to
				XDG_DATA_HOME=${baseDir}
    --base-type config|data|runtime|cache|temp
				Set the base directory based on the passed
				characterization. The default is "data".
    --schema|-s "KEY COL1 [...]"Optional database schema; will be included as a
				commented first line in the data file.
    --namespace|-n NAMESPACE	Optional application / use case for this tool's
				use. Determines the table directory.
    --table|-t TABLE		Category in the context of the application.
				Determines the table file.
    --update|-u RECORD		Record RECORD, which must consist of a KEY + tab
				+ optional additional columns. An existing
				record with the same KEY is overwritten, else it
				is appended.
    --update|-u KEY		Update specific columns of the record for KEY.
    --column|-v COL1=VALUE1|N=VALUE-N
				Instead of updating the entire record, just
				update specific columns:
				COL1=VALUE1 columns that match the passed schema
				N=VALUE-N   columns with the passed indices,
				starting with 0 for KEY, 1 for COL1
    --column|-v COL1++|N++
				Instead of updating the entire record, just
				atomically increment specific columns:
				COL1++ columns that match the passed schema
				N++    columns with the passed indices,
				starting with 0 for KEY, 1 for COL1
				An empty / non-existing column will be treated
				like 0 and incremented to 1. Only supports
				positive integers (of arbitrary size); any other
				column value will be left untouched.
    --delete|-d KEY		Delete any existing record for KEY.
    --truncate|-C		Delete all existing records; just keep the
				schema. Creates the table if it doesn't exist
				yet.
    --drop|-D			Completely wipe all records and the table file
				itself.
    --query|-q KEY		Query whether a record for KEY exists and return
				it.
    --fallback|-f FALLBACK-KEY
				Lookup FALLBACK-KEY instead if KEY hasn't been
				recorded.
    --columns|-c 0*|*|#|"COL1 [...]"|"N [...]"
				Instead of returning the entire record (--query)
				or nothing (--update), return:
				0*	    all columns (default for --query)
				*	    non-key columns
				#	    all updated columns (--update only)
				"COL1 [...]"columns that match the passed schema
					   (in the order given, as one argument)
				"N [...]"   columns with the passed indices,
					    starting with 0 for KEY, 1 for COL1
				When updating, the values from before the update
				are returned.
    --as-escaped-lines		Instead of returning the record in the original
				format, return each column as a separate line.
				Newlines and backslashes contained within a
				column will be escaped as \\n and \\\\,
				respectively, so that newlines don't interfere
				with the line structure and parsing.
    --as-shell-variables	Instead of returning the record in the original
				format, return each column as a separate shell
				variable, named after the schema (or COL0, COL1,
				... if no schema is passed nor defined on the
				table). The output is expected to be eval'd to
				define the variables.
    --unescape|-E OUTPUT|[-]	Interpret escaped backslashes and newlines from
				a query with --as-escaped-lines into the
				original text (of a single column; you could
				pass multiple columns, but then the column
				borders would be lost).
    --query-keys|-k		List all available keys.
    --command "COMMANDLINE"	Execute shell command(s) on TABLE (presumably
				within a transaction)${fileMarker:+; $fileMarker is replaced with its
				filespec}.
				No check is done whether TABLE already exists.
    --read-command "COMMANDLINE"
				Same, but only acquire a read lock; the commands
				must not modify the TABLE.
    --each COMMANDLINE		Invoke COMMANDLINE once for each record. Values
				for the current record's columns are available
				in shell variables that correspond to the
				table's schema. If you didn't define a schema on
				table creation you can refer to columns via the
				COL array (KEY is 0), or explicitly provide one
				via --schema now.
				If there are multiple COMMANDLINEs, each will be
				a separate pass over the table.
    --before COMMANDLINE	Execute COMMANDLINE before any iteration; this
				can be used to initialize some variables used
				within the iteration.
    --after COMMANDLINE		Execute COMMANDLINE after all iterations; this
				can be used to use accumulated iteration
				results.
TRANSACTIONS:
    --transactional|-x		Lock TABLE during the access so that writes are
				serialized and concurrent reads can only happen
				while no write is under way. Pass this to ensure
				consistency in case there could ever be
				contention over the file.
    --timeout SECONDS		Fail if the lock to check for / start a
				transaction cannot be acquired within SECONDS
				(instead of waiting indefinitely) (because
				another transaction is still active).
				0 means fail rather than wait if the lock cannot
				be acquired immediately.
    --no-transaction|-X		Allow access to TABLE outside of a transaction.
				Note that this may return inconsistent data or
				even cause data loss, unless you know what
				you're doing!
    --silence-transaction-errors
				Don't print transaction-related errors (but keep
				printing warnings). This can be used if a
				fallback action is implemented, e.g.
    $(basename "$1") --start-read-transaction "\$\$"
    value="\$($(basename "$1") --within-transaction "\$\$" --query ...)"
    if ! $(basename "$1") --silence-transaction-errors --upgrade-to-write-transaction "\$\$"
    then
	$(basename "$1") --silence-transaction-errors --end-transaction "\$\$"
	if $(basename "$1") --start-write-transaction "\$\$"; then
	    value="\$($(basename "$1") --within-transaction "\$\$" --query ...)"
	else
	    # error
	fi
    fi
    $(basename "$1") --within-transaction "\$\$" --update ... \$value
    $(basename "$1") --end-transaction "\$\$"
    --start-read-transaction OWNER-ID
				Start a transaction that does not modify TABLE.
				Until --end-transaction (or TX-TIMEOUT), no
				other updates to the TABLE are possible.
    --start-write-transaction OWNER-ID
				Start a transaction that modifies TABLE.
				Until --end-transaction (or TX-TIMEOUT), no
				other reads or updates to the TABLE are
				possible.
    --upgrade-to-write-transaction OWNER-ID
				Change a held transaction that was started with
				--start-read-transaction (and hasn't become
				shared) to also allow modifications of TABLE.
				Until --end-transaction (or TX-TIMEOUT, which is
				extended), no other reads or updates to the
				TABLE are possible.
    --transaction-timeout TX-TIMEOUT
				A transition is automatically aborted if more
				than TX-TIMEOUT (default 3) seconds passed since
				--start-*-transaction.
    --within-transaction OWNER-ID
				Perform an action within the transaction.
    --end-transaction OWNER-ID
				End the transaction, so that other clients can
				do updates again. If this does not happen within
				TX-TIMEOUT, another transaction may be started
				and aborts this one.
    --abort-write-transaction OWNER-ID
				End the transaction, and undo any writes done
				within it.
EXIT STATUS:
    0	Complete success.
    1	Failed to read / write / remove the table file.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	The queried KEY (nor FALLBACK-KEY if given) / to-be-deleted key does not
	exist.
    5	Time out while waiting to start a transaction.
    6	The current transaction has taken too long (TX-TIMEOUT). On
	modifications --within-transaction, aborts. On --end-transaction, if it
	was pre-empted by another one, any updates have been lost.

Example:
HELPTEXT
printf '%q %s\n' "$(basename "$1")" '--schema "WINDOWID TIMESTAMP" --table creationTimes --update "$WINDOWID	$(date +%s)"'
printf '%q %s\n' "$(basename "$1")" '--schema "WINDOWID TIMESTAMP" --table creationTimes --update --column "TIMESTAMP=$(date +%s)"'
printf '%q %s\n' "$(basename "$1")" "--schema \"ID VALUE\" -t data --command 'if [ -r {} ]; then tail -n +2 {}; else echo >&2 \"No records exist yet.\"; exit 1; fi'"
printf '\nQueries:\n'
printf 'queryResult="$(%q %s)";\n' "$(basename "$1")" '--table creationTimes --query 123'
printf "    IFS=$'\\\\t'"' read -r -a COLS <<<"$queryResult" # Does not handle empty columns!\n'
printf 'queryResult="$(%q %s)";\n' "$(basename "$1")" '--table creationTimes --query 123 --as-shell-variables'
printf '    eval "$queryResult" # Using eval.\n'
printf 'queryResult="$(%q %s)";\n' "$(basename "$1")" '--table creationTimes --query 123 --as-escaped-lines'
printf '    mapfile -t COLS <<<"$queryResult";\n'
printf '    COL1="$(%q %s)"; COL2="$(...)" # With unescaping.\n' "$(basename "$1")" '--unescape "${COL[1]}"'
printf '\nTransactional Example:\n'
printf '%q %s\n' "$(basename "$1")" '--start-read-transaction "$$" --table creationTimes'
printf '%q %s\n' "$(basename "$1")" '--within-transaction "$$" --table creationTimes --query 123'
printf '%q %s\n' "$(basename "$1")" '--upgrade-to-write-transaction "$$" --table creationTimes'
printf '%q %s\n' "$(basename "$1")" '--within-transaction "$$" --table creationTimes --delete 123'
printf '%q %s\n' "$(basename "$1")" '--end-transaction "$$" --table creationTimes'
printf 'or:\n'
printf '%q %s\n' "$(basename "$1")" '--transactional --table creationTimes --query 123'
}

sedWrapper()
{
    local sedPrefix
    case ",${DEBUG:-}," in
	*,miniDB:sed,*) sedPrefix=verbose;;
	*,miniDB:sed\!,*) sedPrefix=echotrace;;
    esac
    VERBOSE_IFS="${VERBOSE_IFS-newline}" ECHOTRACE_IFS="${ECHOTRACE_IFS-newline}" $sedPrefix sed "$@"
}

containsTab()
{
    [[ "${1?}" =~ $'\t' ]]
}
literalPattern()
{
    sed -e 's/[][\$*.^/]/\\&/g'
}
escapeNewline()
{
    sed ':a; s/\\/\\\\/g; x; G; 1s/\n//; s/\n/\\n/; h; N; s/.*\n//; ta' <<<"${1?}"
}
unescape()
{
    [ $# -ge 1 ] && line="$1"
    echo -e "${line/#-/\\x2d}"
}
readonly ACTIONS='--update, --delete, --truncate, --drop, --[read-]command, --each, --query[-keys], --unescape, --start-read-transaction, --start-write-transaction, --upgrade-to-write-transaction, --within-transaction, --end-transaction, --abort-write-transaction'
multipleActionsError()
{
    echo >&2 "ERROR: Only one of $ACTIONS allowed."
    echo >&2
    printUsage "$1" >&2
    exit 2
}
multipleTransactionsError()
{
    echo >&2 "ERROR: --transactional cannot be combined with --no-transaction or the --start-read-transaction|--start-write-transaction|--upgrade-to-write-transaction|--within-transaction|--end-transaction|--abort-write-transaction set, and only one from the set can be given."
    echo >&2
    printUsage "$1" >&2
    exit 2
}
needReadLock=
transactionOwner=
waitTimeout=
transactionTimeout=3
readonly SED_ONE_COLUMN_PATTERN='[^\t]*'
readonly SED_PRECEDING_COLUMN_PATTERN="\\(${SED_ONE_COLUMN_PATTERN}\\t\\)"
readonly DEFAULT_SCHEMA='KEY COLUMN ...'
typeset -a schema=()
typeset -a normalizedSchema=()
namespace=
table=
line=
key=
fallbackKey=
preAction='ensureNotTransactional'
action=
postAction=
typeset -a queriedColumns=()
typeset -a updatedColumns=()
typeset -A updatedColumnValues=()
isOmitKey=
isOutputFullRecord=
isOutputChangedColumns=
outputFormat=
typeset -a commandLines=()
beforeCommands=
afterCommands=
typeset -a lockControllerArgs=()
isSilenceTransactionErrors=
commands=
readonly INCREMENT_VALUE=$'\t'	# Use the forbidden tab character as an indicator that the column should be incremented.
hasIncrement=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--basedir)	shift; baseDir="$1"; shift;;
	--base-type)	shift
			case "$1" in
			    config)	baseDir="${XDG_CONFIG_HOME:-$HOME/.config}";;
			    data)	baseDir="${XDG_DATA_HOME:-$HOME/.local/share}";;
			    runtime)	baseDir="${XDG_RUNTIME_DIR:-/run/user/$UID}";;
			    cache)	baseDir="${XDG_CACHE_HOME:-$HOME/.cache}";;
			    temp)	baseDir="${TMPDIR:-/tmp}";;
			    *)		printf >&2 'ERROR: Invalid base-type "%s".\n' "$1"
					echo >&2
					printUsage "$0" >&2
					exit 2
					;;
			esac
			shift
			;;
	--no-transaction|-X)		shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction='';;
	--transactional|-x)		shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction='startTransaction'; postAction='endTransaction'; transactionOwner="$$";;
	--within-transaction)		shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction='checkTransaction'; transactionOwner="$1"; shift;;
	--start-read-transaction)	shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction=''; [ "$action" ] && multipleActionsError "$0"; action='startTransaction'; needReadLock=t; transactionOwner="$1"; shift;;
	--start-write-transaction)	shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction=''; [ "$bction" ] && multipleActionsError "$0"; action='startTransaction'; transactionOwner="$1"; shift;;
	--upgrade-to-write-transaction)	shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction=''; [ "$action" ] && multipleActionsError "$0"; action='upgradeTransaction'; transactionOwner="$1"; shift;;
	--end-transaction)		shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction=''; [ "$action" ] && multipleActionsError "$0"; action='endTransaction'; transactionOwner="$1"; shift;;
	--abort-write-transaction)	shift; [ -n "$transactionOwner" -o -z "$preAction" ] && multipleTransactionsError "$0"; preAction=''; [ "$action" ] && multipleActionsError "$0"; action='abortWriteTransaction'; transactionOwner="$1"; shift;;
	--timeout)			shift; waitTimeout="$1"; shift;;
	--silence-transaction-errors)	isSilenceTransactionErrors=t; lockControllerArgs+=("$1"); shift;;
	--transaction-timeout)		shift; transactionTimeout="$1"; shift;;
	--schema|-s)	shift; schema=($1); shift
			if [ ${#schema[@]} -eq 0 ]; then
			    echo 'ERROR: No schema passed.'
			    echo
			    printUsage "$0"
			    exit 2
			fi >&2
			;;
	--namespace|-n)	shift; namespace="$1"; shift;;
	--table|-t)	shift; table="$1"; shift
			if [[ "$table" = */* ]]; then
			    echo 'ERROR: TABLE must not contain slashes.'
			    echo
			    printUsage "$0"
			    exit 2
			fi >&2
			;;
	--fallback|-f)	shift; fallbackKey="$1"; shift;;
	--update|-u)	shift; [ "$action" ] && multipleActionsError "$0"; action='update'; line="$1"; shift
			containsTab "$line" || line+=$'\t'   # Need at least one tab separator.
			;;
	--column|-v)	shift
			if [[ "$1" =~ \+\+$ ]]; then
			    column="${1%++}"
			    updatedColumnValues["$column"]="$INCREMENT_VALUE"
			    hasIncrement=t
			else
			    column="${1%%=*}"
			    value="${1#*=}"
			    if [[ ! "$1" =~ = ]] || [ -z "$column" ]; then
				echo 'ERROR: Column values must be specified as COL1=VALUE1 or N=VALUE-N (or increment via COL1++ / N++).'
				echo
				printUsage "$0"
				exit 2
			    elif containsTab "$value"; then
				echo 'ERROR: VALUE cannot contain tab characters.'
				echo
				printUsage "$0"
				exit 2
			    fi >&2
			    updatedColumnValues["$column"]="$(escapeNewline "$value")"
			fi
			updatedColumns+=("$column")
			shift
			;;
	--delete|-d)	shift; [ "$action" ] && multipleActionsError "$0"; action='delete'; key="$1"; shift
			if containsTab "$key"; then
			    echo 'ERROR: KEY cannot contain tab characters.'
			    echo
			    printUsage "$0"
			    exit 2
			elif [ ! "$key" ]; then
			    echo 'ERROR: KEY must not be empty.'
			    echo
			    printUsage "$0"
			    exit 2
			fi >&2
			;;
	--truncate|-C)	shift; [ "$action" ] && multipleActionsError "$0"; action='truncate';;
	--drop|-D)	shift; [ "$action" ] && multipleActionsError "$0"; action='drop'; postPostAction='removeLock';;
	--query|-q)	shift; [ "$action" ] && multipleActionsError "$0"; action='query'; key="$1"; needReadLock=t; shift
			if containsTab "$key"; then
			    echo 'ERROR: KEY cannot contain tab characters.'
			    echo
			    printUsage "$0"
			    exit 2
			elif [ ! "$key" ]; then
			    echo 'ERROR: KEY must not be empty.'
			    echo
			    printUsage "$0"
			    exit 2
			fi >&2
			;;
	--query-keys|-k)
			shift; [ "$action" ] && multipleActionsError "$0"; action='queryKeys'; needReadLock=t;;
	--columns|-c)	shift
			if [ "$1" = '*' ]; then
			    isOmitKey=t
			elif [ "$1" = '0*' ]; then
			    isOutputFullRecord=t
			elif [ "$1" = '#' ]; then
			    isOutputChangedColumns=t
			else
			    queriedColumns=($1)
			    if [ ${#queriedColumns[@]} -eq 0 ]; then
				echo 'ERROR: No columns passed.'
				echo
				printUsage "$0"
				exit 2
			    fi >&2
			fi
			shift
			;;
	--as-escaped-lines)
			shift; outputFormat='escapedLines';;
	--as-shell-variables)
			shift; outputFormat='shellVariables';;
	--unescape|-E)	shift; [ "$action" ] && multipleActionsError "$0"; action='unescape'

			if [ $# -eq 0 -o "$1" = '-' ]; then
			    line="$(< /dev/stdin)"
			else
			    line="${1?}"
			fi
			shift
			table='dummy'	# Need to set this as it's mandatory for all other actions, but not used for unescape.
			;;
	--read-command)	shift; [ "$action" ] && [ "$action" != 'commandline' ] && multipleActionsError "$0"; [ "$action" ]|| needReadLock=t; action='commandline'; commands+="${commands:+ $MINIDB_COMMAND_JOINER }$1"; shift;;
	--command)	shift; [ "$action" ] && [ "$action" != 'commandline' ] && multipleActionsError "$0"; needReadLock=; action='commandline'; commands+="${commands:+ $MINIDB_COMMAND_JOINER }$1"; shift;;
	--each|-e)	shift; [ "$action" -a "$action" != 'each' ] && multipleActionsError "$0"; action='each'; needReadLock=t; commandLines+=("$1"); shift;;
	--before)	shift; beforeCommands+="${beforeCommands:+ $MINIDB_COMMAND_JOINER }$1"; shift;;
	--after)	shift; afterCommands+="${afterCommands:+ $MINIDB_COMMAND_JOINER }$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 0 ]; then
    [ "$action" ] && [ "$action" != 'commandline' ] && multipleActionsError "$0"
    action='commandline'
    needReadLock=

    # Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
    # undo the effects of eval.
    printf -v quotedSimpleCommand '%q ' "$@"
    printf -v escapedFileMarker %q "$fileMarker"
    commands+="${commands:+ $MINIDB_COMMAND_JOINER }${quotedSimpleCommand//"$escapedFileMarker"/$fileMarker}"	# %q escapes {}, we don't want that to have it interpolated later.
fi
if [ ! "$action" ]; then
    echo "ERROR: No action passed: $ACTIONS"
    echo
    printUsage "$0"
    exit 2
elif [ ! "$table" ]; then
    echo 'ERROR: No TABLE passed.'
    echo
    printUsage "$0"
    exit 2
elif [ "${transactionOwner:0:1}" = '*' ]; then
    echo 'ERROR: OWNER-ID must not start with *.'
    echo
    printUsage "$0"
    exit 2
fi >&2
if [ "$action" = unescape ]; then
    # Need no transactions around unescaping.
    preAction=
    postAction=
fi


translateColumnNamesToIndices()
{
    # Translate any queried column names into the corresponding indices, using
    # the provided schema.

    typeset -A schemaToIndex=()
    for ((i = 0; i < ${#schema[@]}; i++))
    do
	schemaToIndex["${schema[$i]}"]="$i"
    done

    for ((i = 0; i < ${#queriedColumns[@]}; i++))
    do
	case "${queriedColumns[$i]}" in
	    +([0-9]))
		;;
	    *)
		index="${schemaToIndex["${queriedColumns[$i]}"]}"
		if [ -n "$index" ]; then
		    queriedColumns[$i]="$index"
		elif [ ${#schema[@]} -eq 0 ]; then
		    return 1
		else
		    printf >&2 'ERROR: Unknown column %s; not an index nor named in schema %s.\n' "${queriedColumns[$i]}" "${schema[*]}"
		    exit 2
		fi
		;;
	esac
    done

    for ((i = 0; i < ${#updatedColumns[@]}; i++))
    do
	case "${updatedColumns[$i]}" in
	    +([0-9]))
		;;
	    *)
		index="${schemaToIndex["${updatedColumns[$i]}"]}"
		if [ -n "$index" ]; then
		    updatedColumnValues[$index]="${updatedColumnValues["${updatedColumns[$i]}"]}"
		    unset updatedColumnValues["${updatedColumns[$i]}"]
		    updatedColumns[$i]="$index"
		elif [ ${#schema[@]} -eq 0 ]; then
		    return 1
		else
		    printf >&2 'ERROR: Unknown column %s; not an index nor named in schema %s.\n' "${updatedColumns[$i]}" "${schema[*]}"
		    exit 2
		fi
		;;
	esac
    done
}
loadSchemaFromTable()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    local schemaLine="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e b -e ':skipHeader' -e 'p' -- "$TABLE_FILESPEC")"
    [ "$schemaLine" ] || return 1

    local IFS=' '; typeset -a defaultSchema=($DEFAULT_SCHEMA)
    local IFS=$'\t'; schema=(${schemaLine#\# })
    [ ${#schema[@]} -gt 0 -a "${schema[*]}" = "${defaultSchema[*]}" ] && schema=()
    [ ${#schema[@]} -gt 0 ]
}

normalizeSchema()
{
    normalizedSchema=("${schema[@]}")
    normalizedSchema=("${normalizedSchema[@]/#[^a-zA-Z_]/_}")
    normalizedSchema=("${normalizedSchema[@]//[^a-zA-Z0-9_]/_}")
}
parseColumns()
{
    local line="$1"; shift
    [ "$line" ] || return

    while [ "${line/$'\t'/}" != "$line" ]
    do
	columns+=("${line%%$'\t'*}")
	line="${line#*$'\t'}"
    done
    columns+=("$line")
}

query()
{
    [ -e "$TABLE_FILESPEC" ] || return 1

    if [ "$isOutputChangedColumns" ]; then
	echo >&2 'ERROR: Updated columns can only be queried in combination with --update.'
	exit 2
    fi

    # Escape newlines and backslashes.
    [ "${key/[$'\n'\\]/}" = "$key" ] || key="$(escapeNewline "$key")"
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    if [ "$fallbackKey" ]; then
	# Get the $key line, with fallback to $fallbackKey
	[ "${fallbackKey/[$'\n'\\]/}" = "$fallbackKey" ] || fallbackKey="$(escapeNewline "$fallbackKey")"
	local literalFallbackPattern="$(printf %s "$fallbackKey" | literalPattern)"
	local line="$(sedWrapper -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t\\|^${literalFallbackPattern}\\t/H" -e "\${ g; s/^\\n//; s/^${literalFallbackPattern}\\t.*\\n//; s/\\n${literalFallbackPattern}\\t.*\$//; /./p }" -e ':skipHeader' -- "$TABLE_FILESPEC")"
    else
	local line="$(sedWrapper -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t/p" -e ':skipHeader' -- "$TABLE_FILESPEC")"
    fi
    [ "$line" ] || return 4

    outputQueriedLine "$line"
}
outputQueriedLine()
{
    local line="${1:?}"; shift
    local IFS=$'\t'
    local fullLine="$line"
    if [ "$isOmitKey" ]; then
	line="${line#*$'\t'}"
    elif [ ${#queriedColumns[@]} -gt 0 ]; then
	typeset -a columns=(); parseColumns "$line"
	local newLine=
	local separator=
	for c in "${queriedColumns[@]}"
	do
	    newLine+="${separator}${columns[$c]}"
	    separator=$'\t'
	done
	line="$newLine"
    fi

    case "$outputFormat" in
	escapedLines)
	    typeset -a columns=(); parseColumns "$line"
	    [ ${#columns[@]} -gt 0 ] && printf '%s\n' "${columns[@]}"
	    ;;
	shellVariables)
	    if [ ${#queriedColumns[@]} -eq 0 ]; then
		typeset -a columns=(); parseColumns "$fullLine"
		if [ ${#schema[@]} -eq 0 ]; then
		    if ! loadSchemaFromTable; then
			local lastCol=$((${#columns[@]} - 1))
			eval "schema=({0..$lastCol})"
			schema=("${schema[@]/#/COL}")
		    fi
		fi
		local end=$((${#schema[@]} - 1))
		local start=0; [ "$isOmitKey" ] && start=1
		eval "queriedColumns=({$start..$end})"
	    fi

	    normalizeSchema
	    for c in "${queriedColumns[@]}"
	    do
		local value="$(unescape "${columns[$c]}x")"
		printf '%s=%q\n' "${normalizedSchema[$c]}" "${value%x}"
	    done
	    ;;
	'') unescape "$line";;
	*)  printf >&2 'ASSERT: Unknown outputFormat: %s\n' "$outputFormat"; exit 2;;
    esac
}

initializeTable()
{
    local IFS=' '; [ ${#schema[@]} -eq 0 ] && schema=($DEFAULT_SCHEMA)
    local IFS=$'\t'
    printf > "$TABLE_FILESPEC" '# %s\n' "${schema[*]}"
}
update()
{
    # Need to write at least one line so that sed does processing; can use that for a descriptive header.
    [ -s "$TABLE_FILESPEC" ] || initializeTable || return 1

    # Escape newlines and backslashes.
    [ "${line/[$'\n'\\]/}" = "$line" ] || line="$(escapeNewline "$line")"

    local isOutput; [ ${#queriedColumns[@]} -gt 0 ] || [ "$isOmitKey" ] || [ "$isOutputFullRecord" ] || [ "$isOutputChangedColumns" ] && isOutput=t

    if [ ${#updatedColumnValues[@]} -eq 0 ]; then
	updateFullRecord "$isOutput"
    else
	if [ "$isOutputChangedColumns" ]; then
	    queriedColumns=("${updatedColumns[@]}")
	fi

	updateSpecifiedColumns "$isOutput"
    fi
}
updateFullRecord()
{
    local isOutput="${1?}"; shift
    local key="${line%%$'\t'*}"
    if [ ! "$key" ]; then
	echo >&2 'ERROR: KEY must not be empty.'
	exit 2
    fi

    local literalKeyPattern="$(printf %s "$key" | literalPattern)"
    typeset -a sedOutputCommand=()
    [ "$isOutput" ] && sedOutputCommand=(-e "/^${literalKeyPattern}\\t/w /dev/stdout")

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that we don't need to append the line at the end.
    # On the last line, we check the hold space, and skip further processing of
    # the line if the hold space isn't empty.
    sedWrapperHandlingQueriedColumns "$isOutput" -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/h" \
	"${sedOutputCommand[@]}" \
	-e "/^${literalKeyPattern}\\t/c\\
${line//\\/\\\\}"  \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e "\$a\\
${line//\\/\\\\}" || return 1
}
updateSpecifiedColumns()
{
    local IFS=$'\t'
    local key="${line%$'\t'}"	# Undo the appended tab separator.
    if [ ! "$key" ]; then
	echo >&2 'ERROR: KEY must not be empty.'
	exit 2
    fi

    local literalKeyPattern="$(printf %s "$key" | literalPattern)"
    typeset -a sedOutputCommand=()
    [ "$isOutput" ] && sedOutputCommand=(-e "/^${literalKeyPattern}\\t/w /dev/stdout")

    typeset -a sedUpdateColumnsArguments=()
    typeset -a sedProcedures=()
    local highestIndex=0
    for c in "${updatedColumns[@]}"
    do
	if [ $c -eq 0 -a -z "${updatedColumnValues[0]}" ]; then
	    echo >&2 'ERROR: KEY must not be empty.'
	    exit 2
	fi
	local sedUpdatePattern='\(\)'	# Need to use empty capture group so the group numbering stays the same when $SED_PRECEDING_COLUMN_PATTERN is used.
	[ $c -ge 1 ] && sedUpdatePattern="${SED_PRECEDING_COLUMN_PATTERN}\\{${c}\\}"
	if [ "${updatedColumnValues[$c]}" = "$INCREMENT_VALUE" ]; then
	    [ ${#sedProcedures[@]} -eq 0 ] && sedProcedures+=(-e b)
	    sedUpdateColumnsArguments+=(
		-e "s#^\\(${sedUpdatePattern}\\)"'\($\|\t\)#\11\3#' -e "t return${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\(9\+\)\($\|\t\)#\11\3\4#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)8\(9*\)\($\|\t\)#\1\3_\4\5#' -e "t rollover${c}"	# Note: Cannot directly increment 8 to 9, as rollover${c} then won't know from where to turn 9s into 0s. Use an intermediate _ symbol instead.
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)7\(9*\)\($\|\t\)#\1\38\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)6\(9*\)\($\|\t\)#\1\37\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)5\(9*\)\($\|\t\)#\1\36\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)4\(9*\)\($\|\t\)#\1\35\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)3\(9*\)\($\|\t\)#\1\34\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)2\(9*\)\($\|\t\)#\1\33\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)1\(9*\)\($\|\t\)#\1\32\4\5#' -e "t rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)0\(9*\)\($\|\t\)#\1\31\4\5#' -e "t rollover${c}"
		-e ":return${c}"
	    )
	    sedProcedures+=(
		-e ":rollover${c}"
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*[0-8]\)9\(9*\)\($\|\t\)#\1\30\4\5#'
		-e "s#^\\(${sedUpdatePattern}\\)"'\([0-9]*\)_9\(9*\)\($\|\t\)#\1\390\4\5#'  # Turn the intermediate _ symbol back into 9 while turning the first 9 into a 0.
		-e "t rollover${c}"
		-e "b return${c}"
	    )
	else
	    local literalValue="${updatedColumnValues[$c]}"
	    literalValue="${literalValue//\\/\\\\}"
	    literalValue="${literalValue//&/\\&}"
	    sedUpdateColumnsArguments+=(-e "s#^\\(${sedUpdatePattern}\\)${SED_ONE_COLUMN_PATTERN}#\\1${literalValue//#/\\#}#")
	    if [ "$hasIncrement" ]; then
		# Following increments would be lead down a wrong path (to
		# rollover${c}) by the successful substitution; we need to clear
		# the substitution flag via a no-op conditional jump.
		sedUpdateColumnsArguments+=(
		    -e "t return${c}"
		    -e ":return${c}"
		)
	    fi
	fi
	[ $c -gt $highestIndex ] && highestIndex=$c
    done
    typeset -a sedEnsureColumnsArguments=()
    [ $highestIndex -ge 2 ] && sedEnsureColumnsArguments=(-e "/${SED_PRECEDING_COLUMN_PATTERN}\\{${highestIndex}\\}"'/!{ s/$/\t/; b updateColumns }')

    [ -z "${updatedColumnValues[0]}" ] && updatedColumnValues[0]="$key"	# Include the key (unless it is part of the updated columns).
    typeset -a newRecord=()
    for ((i = 0; i <= highestIndex; i++))
    do
	if [ "${updatedColumnValues[$i]}" = "$INCREMENT_VALUE" ]; then
	    newRecord+=("1")
	else
	    newRecord+=("${updatedColumnValues[$i]}")
	fi
    done
    [ $highestIndex -eq 0 ] && newRecord+=('')	# Our database format requires a tab after the key.

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that we don't need to append the line at the end.
    # On the last line, we check the hold space, and skip further processing of
    # the line if the hold space isn't empty.
    sedWrapperHandlingQueriedColumns "$isOutput" -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/h" \
	"${sedOutputCommand[@]}" \
	-e "/^${literalKeyPattern}\\t/b updateColumns" \
	-e 'b skipHeader' \
	-e ':updateColumns' \
	"${sedEnsureColumnsArguments[@]}" \
	"${sedUpdateColumnsArguments[@]}" \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e "\$a\\
${newRecord[*]//\\/\\\\}" \
	"${sedProcedures[@]}" || return 1
}
sedWrapperHandlingQueriedColumns()
{
    local isOutput="${1?}"; shift

    if [ "$isOutput" ]; then
	local line; line="$(sedWrapper "$@" -- "$TABLE_FILESPEC")" || return $?
	[ -z "$line" ] || outputQueriedLine "$line"
    else
	sedWrapper "$@" -- "$TABLE_FILESPEC"
    fi
}

delete()
{
    local IFS=$'\t'
    [ -e "$TABLE_FILESPEC" ] || return 1

    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that a deletion was done.
    # On the last line, we check the hold space, and indicate unsuccessful
    # deletion via a special exit status.
    sedWrapper -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/{ h; d; }" \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e '$q 4' \
	-- "$TABLE_FILESPEC"
}

truncate()
{
    if [ -s "$TABLE_FILESPEC" ]; then
	sedWrapper -i "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e d -e ':skipHeader' -- "$TABLE_FILESPEC" || return 1
    else
	initializeTable
    fi
}

drop()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    rm -- "$TABLE_FILESPEC"
}

removeLock()
{
    rm --force -- "$LOCK_FILESPEC" 2>/dev/null
}

commandline()
{
    local interpolatedCommands="${commands//"$fileMarker"/$TABLE_FILESPEC}"
    eval "$interpolatedCommands"
}

iterateOverRecords()
{
    local commandLine="${1?}"; shift
    normalizeSchema

    while IFS=$'\t' read -r "$@" "${normalizedSchema[@]}"
    do
	eval "$commandLine"
    done < <(sedWrapper -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e p -e ':skipHeader' -- "$TABLE_FILESPEC")
}
each()
{
    [ -e "$TABLE_FILESPEC" ] || return 1

    typeset -a iterateReadArgs=()
    if [ ${#schema[@]} -eq 0 ]; then
	if ! loadSchemaFromTable; then
	    iterateReadArgs=(-a COL)
	fi
    fi

    eval "$beforeCommands"
	for cl in "${commandLines[@]}"
	do
	    iterateOverRecords "$cl" "${iterateReadArgs[@]}"
	done
    eval "$afterCommands"
}
queryKeys()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    schema=(key ignoredColumns)
    iterateOverRecords 'echo $key'
}


ensureNotTransactional()
{
    if [ -e "$LOCK_FILESPEC" ]; then
	echo >&2 "This table must be accessed in a transactional manner, using either --transactional or the --start-read-transaction|--start-write-transaction|--upgrade-to-write-transaction|--within-transaction|--end-transaction|--abort-write-transaction set."
	exit 2
    fi
}
lockedCall()
{
    local method="${1:?}"; shift
    local mode=write; [ "$needReadLock" ] && mode=read
    flock "$@" --conflict-exit-code 5 ${waitTimeout:+--timeout "$waitTimeout"} "$LOCK_FILESPEC" transactionalLockController "${lockControllerArgs[@]}" "$method" "$TABLE_FILESPEC" "$LOCK_FILESPEC" "$transactionOwner" "$mode" "$transactionTimeout"
}
startTransaction()
{
    SECONDS=0
    local error
    while :
    do
	error="$(lockedCall TX-START)" || exit $?
	[ ! "$error" ] && break

	if [ -n "$NOW" -o \( -n "$waitTimeout" -a $SECONDS -ge ${waitTimeout:-0} \) ]; then
	    [ "$isSilenceTransactionErrors" ] || printf >&2 '%s\n' "$error"
	    exit 5
	fi

	sleep "${MINIDB_BLOCK_DELAY:-0.01s}"
    done
}
upgradeTransaction()
{
    lockedCall TX-UPGRADE
}
endTransaction()
{
    lockedCall TX-END && \
	if [ ! -e "$TABLE_FILESPEC" ]; then
	    removeLock
	fi
}
abortWriteTransaction()
{
    lockedCall TX-ABORT
}
checkTransaction()
{
    lockedCall TX-CHECK --shared
}



typeset -a IGNORE_HEADER_LINE_SED_ARGS=(-e '1{ /^#/b skipHeader }')

readonly CONFIG_DIRSPEC="${baseDir}${namespace:+/}$namespace"
[ -d "$CONFIG_DIRSPEC" ] || mkdir -p -- "$CONFIG_DIRSPEC" || { printf >&2 'ERROR: Could not initialize database store at %s!\n' "$CONFIG_DIRSPEC"; exit 1; }
readonly TABLE_FILESPEC="${CONFIG_DIRSPEC}/$table"
readonly LOCK_FILESPEC="${CONFIG_DIRSPEC}/.${table}.lock"

if [ ${#queriedColumns[@]} -gt 0 -o ${#updatedColumns[@]} -gt 0 ]; then
    if ! translateColumnNamesToIndices; then
	if ! loadSchemaFromTable; then
	    printf >&2 'ERROR: Cannot resolve named columns from the table %s, as no schema is defined there. Use indices or pass a --schema SCHEMA.\n' "${namespace}${namespace:+/}${table}"
	    exit 2
	fi
	translateColumnNamesToIndices
    fi
fi

if [ "$preAction" ]; then
    "$preAction" || exit $?
fi
"$action"
status=$?
if [ "$postAction" ]; then
    "$postAction"
fi
exit $status
