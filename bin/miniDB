#!/bin/bash
###############################################################################
##
# FILE:		miniDB
# PRODUCT:	tools
# AUTHOR:	Ingo Karkat <ingo@karkat.de>
# DATE CREATED:	04-Apr-2019
#
###############################################################################
# CONTENTS:
#   A lightweight file-based columnar database supporting CRUD operations with a
#   single lookup key.
#
# REMARKS:
#
# @(#)miniDB	$Id$	tools
###############################################################################
set -o noglob
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-s|--schema "KEY COL1 [COL2 ...]"] [-n|--namespace NAMESPACE] -t|--table TABLE [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -u|--update RECORD'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -d|--delete KEY'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -D|--drop'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -e|--each "COMMANDLINE" [-e|--each ...] [--before "COMMANDLINE" [--before ...]] [--after "COMMANDLINE" [--after ...]]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -q|--query KEY [-f|--fallback FALLBACK-KEY] [-c|--columns *|COL1 [...]|N [...]] [--as-escaped-lines|--as-shell-variables]'
    printf 'Usage: %q -x|--unescape "$(%q %s)"\n' "$(basename "$1")" "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-escaped-lines'
    printf 'Usage: eval "$(%q %s)"\n' "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-shell-variables'
    printf 'Usage: %q %s\n' "$(basename "$1")" '... -k|--query-keys'
    printf 'Usage: %q %s | %q -x|--unescape [-]\n' "$(basename "$1")" '-q|--query KEY -c|--columns COLN|N --as-escaped-lines' "$(basename "$1")"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Records and retrieves individual LINEs based on a single KEY lookup inside a
TABLE [within NAMESPACE], using simple tab-separated data files as storage.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --schema|-s "KEY COL1 [...]"Optional database schema; will be included as a
				commented first line in the data file.
    --namespace|-n NAMESPACE	Optional application / use case for this tool's
				use. Determines the configuration directory.
    --table|-t TABLE		Category in the context of the application.
				Determines the configuration file.
    --update|-u RECORD		Record RECORD, which must consist of a KEY + tab
				+ optional additional columns. An existing
				record with the same KEY is overwritten, else it
				is appended.
    --delete|-d KEY		Delete any existing record for KEY.
    --drop|-D			Completely wipe all records and the table
				configuration file itself.
    --query|-q KEY		Query whether a record for KEY exists and return
				it.
    --fallback|-f FALLBACK-KEY
				Lookup FALLBACK-KEY instead if KEY hasn't been
				recorded.
    --columns|-c		Instead of returning the entire record, just
				return:
				* non-key columns
				COL1 [...] columns that match the passed schema
					   (in the order given)
				N [...]	   columns with the passed indices,
					   starting with 0 for KEY, 1 for COL1
    --as-escaped-lines		Instead of returning the record in the original
				format, return each column as a separate line.
				Newlines and backslashes contained within a
				column will be escaped as \\n and \\\\,
				respectively, so that newlines don't interfere
				with the line structure and parsing.
    --as-escaped-lines		Instead of returning the record in the original
				format, return each column as a separate shell
				variable, named after the schema (or COL0, COL1,
				... if no schema is passed nor defined on the
				table). The output is expected to be eval'd to
				define the variables.
    --unescape|-x OUTPUT|[-]	Interpret escaped backslashes and newlines from
				a query with --as-escaped-lines into the
				original text (of a single column; you could
				pass multiple columns, but then the column
				borders would be lost).
    --query-keys|-k		List all available keys.
    --each COMMANDLINE		Invoke COMMANDLINE once for each record. Values
				for the current record's columns are available
				in shell variables that correspond to the
				table's schema. If you didn't define a schema on
				table creation you can refer to columns via the
				COL array (KEY is 0), or explicitly provide one
				via --schema now.
				If there are multiple COMMANDLINEs, each will be
				a separate pass over the table.
    --before COMMANDLINE	Execute COMMANDLINE before any iteration; this
				can be used to initialize some variables used
				within the iteration.
    --after COMMANDLINE		Execute COMMANDLINE after all iterations; this
				can be used to use accumulated iteration
				results.
EXIT STATUS:
    0	Complete success.
    1	Failed to read / write / remove the table file.
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	The queried KEY (nor FALLBACK-KEY if given) / to-be-deleted key does not
	exist.

Example:
HELPTEXT
printf '%q %s\n' "$(basename "$1")" '--schema "WINDOWID TIMESTAMP" --table creationTimes --update "$WINDOWID	$(date +%s)"'
printf '%q %s\n' "$(basename "$1")" '--table creationTimes --query 123456'
}

containsTab()
{
    [[ "${1?}" =~ $'\t' ]]
}
multipleActionsError()
{
    echo >&2 "ERROR: Only one of --update, --query allowed."
    echo >&2
    printShortUsage "$1" >&2
    exit 2
}
readonly DEFAULT_SCHEMA='KEY COLUMN ...'
typeset -a schema=()
typeset -a normalizedSchema=()
namespace=
table=
line=
key=
fallbackKey=
action=
typeset -a queriedColumns=()
isOmitKey=
outputFormat=
typeset -a commandLines=()
typeset -a beforeCommands=()
typeset -a afterCommands=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--schema|-s)	shift; schema=($1); shift
			if [ ${#schema[@]} -eq 0 ]; then
			    echo >&2 'ERROR: No schema passed.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			fi
			;;
	--namespace|-n)	shift; namespace="$1"; shift;;
	--table|-t)	shift; table="$1"; shift;;
	--fallback|-f)	shift; fallbackKey="$1"; shift;;
	--update|-u)	shift; [ "$action" ] && multipleActionsError "$0"; action='update'; line="$1"; shift
			containsTab "$line" || line="${line}$'\t'"   # Need at least one tab separator.
			;;
	--delete|-d)	shift; [ "$action" ] && multipleActionsError "$0"; action='delete'; key="$1"; shift
			if containsTab "$key"; then
			    echo >&2 'ERROR: KEY cannot contain tab characters.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			elif [ ! "$key" ]; then
			    echo >&2 'ERROR: Key must not be empty.'
			    exit 2
			fi
			;;
	--drop|-D)	shift; [ "$action" ] && multipleActionsError "$0"; action='drop';;
	--query|-q)	shift; [ "$action" ] && multipleActionsError "$0"; action='query'; key="$1"; shift
			if containsTab "$key"; then
			    echo >&2 'ERROR: KEY cannot contain tab characters.'
			    echo >&2
			    printShortUsage "$0" >&2
			    exit 2
			elif [ ! "$key" ]; then
			    echo >&2 'ERROR: Key must not be empty.'
			    exit 2
			fi
			;;
	--query-keys|-k)
			shift; [ "$action" ] && multipleActionsError "$0"; action='queryKeys';;
	--columns|-c)	shift
			if [ "$1" = '*' ]; then
			    isOmitKey=t
			else
			    queriedColumns=($1)
			    if [ ${#queriedColumns[@]} -eq 0 ]; then
				echo >&2 'ERROR: No columns passed.'
				echo >&2
				printShortUsage "$0" >&2
				exit 2
			    fi
			fi
			shift
			;;
	--as-escaped-lines)
			shift; outputFormat='escapedLines';;
	--as-shell-variables)
			shift; outputFormat='shellVariables';;
	--unescape|-x)	shift; [ "$action" ] && multipleActionsError "$0"; action='unescape'

			if [ $# -eq 0 -o "$1" = '-' ]; then
			    line="$(< /dev/stdin)"
			else
			    line="${1?}"
			fi
			shift
			table='dummy'	# Need to set this as it's mandatory for all other actions, but not used for unescape.
			;;
	--each|-e)	shift; [ "$action" -a "$action" != 'each' ] && multipleActionsError "$0"; action='each'; commandLines+=("$1"); shift;;
	--before)	shift; beforeCommands+=(${beforeCommands:+;} "$1"); shift;;
	--after)	shift; afterCommands+=(${afterCommands:+;} "$1"); shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -gt 0 ]; then
    printShortUsage "$0" >&2
    exit 2
elif [ ! "$action" ]; then
    echo >&2 "ERROR: No action passed."
    echo >&2
    printShortUsage "$0" >&2
    exit 2
elif [ ! "$table" ]; then
    echo >&2 'ERROR: No TABLE passed.'
    echo >&2
    printShortUsage "$0" >&2
    exit 2
fi


translateColumnNamesToIndices()
{
    # Translate any queried column names into the corresponding indices, using
    # the provided schema.

    typeset -A schemaToIndex=()
    for ((i = 0; i < ${#schema[@]}; i++))
    do
	schemaToIndex["${schema[$i]}"]="$i"
    done

    for ((i = 0; i < ${#queriedColumns[@]}; i++))
    do
	case "${queriedColumns[$i]}" in
	    +([0-9]))
		;;
	    *)
		index="${schemaToIndex["${queriedColumns[$i]}"]}"
		if [ "$index" ]; then
		    queriedColumns[$i]="$index"
		elif [ ${#schema[@]} -eq 0 ]; then
		    return 1
		else
		    printf >&2 'ERROR: Unknown column %s; not an index nor named in schema %s.\n' "${queriedColumns[$i]}" "${schema[*]}"
		    exit 2
		fi
		;;
	esac
    done
}
loadSchemaFromTable()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    local schemaLine="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e b -e ':skipHeader' -e 'p' -- "$TABLE_FILESPEC")"
    [ "$schemaLine" ] || return 1

    local IFS=' '; typeset -a defaultSchema=($DEFAULT_SCHEMA)
    local IFS=$'\t'; schema=(${schemaLine#\# })
    [ ${#schema[@]} -gt 0 -a "${schema[*]}" = "${defaultSchema[*]}" ] && schema=()
    [ ${#schema[@]} -gt 0 ]
}

literalPattern()
{
    sed -e 's/[][\$*.^/]/\\&/g'
}
escapeNewline()
{
    sed ':a; s/\\/\\\\/g; x; G; 1s/\n//; s/\n/\\n/; h; N; s/.*\n//; ta' <<<"${1:?}"
}
unescape()
{
    [ $# -ge 1 ] && line="$1"
    echo -e "${line/#-/\\x2d}"
}
normalizeSchema()
{
    normalizedSchema=("${schema[@]}")
    normalizedSchema=("${normalizedSchema[@]/#[^a-zA-Z_]/_}")
    normalizedSchema=("${normalizedSchema[@]//[^a-zA-Z0-9_]/_}")
}

query()
{
    local IFS=$'\t'
    [ -e "$TABLE_FILESPEC" ] || return 1

    # Escape newlines and backslashes.
    [ "${key/[$'\n'\\]/}" = "$key" ] || key="$(escapeNewline "$key")"
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    if [ "$fallbackKey" ]; then
	# Get the $key line, with fallback to $fallbackKey
	[ "${fallbackKey/[$'\n'\\]/}" = "$fallbackKey" ] || fallbackKey="$(escapeNewline "$fallbackKey")"
	local literalFallbackPattern="$(printf %s "$fallbackKey" | literalPattern)"
	local line="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t\\|^${literalFallbackPattern}\\t/H" -e "\${ g; s/^\\n//; s/^${literalFallbackPattern}\\t.*\\n//; s/\\n${literalFallbackPattern}\\t.*\$//; /./p }" -e ':skipHeader' -- "$TABLE_FILESPEC")"
    else
	local line="$(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e "/^${literalKeyPattern}\\t/p" -e ':skipHeader' -- "$TABLE_FILESPEC")"
    fi
    [ "$line" ] || return 4

    local fullLine="$line"
    if [ "$isOmitKey" ]; then
	line="${line#*$'\t'}"
    elif [ ${#queriedColumns[@]} -gt 0 ]; then
	typeset -a columns=($line)
	local newLine=
	local separator=
	for c in "${queriedColumns[@]}"
	do
	    newLine="${newLine}${separator}${columns[$c]}"
	    separator=$'\t'
	done
	line="$newLine"
    fi

    case "$outputFormat" in
	escapedLines)
	    typeset -a columns=($line)
	    printf '%s\n' "${columns[@]}"
	    ;;
	shellVariables)
	    if [ ${#queriedColumns[@]} -eq 0 ]; then
		typeset -a columns=($fullLine)
		if [ ${#schema[@]} -eq 0 ]; then
		    if ! loadSchemaFromTable; then
			local lastCol=$((${#columns[@]} - 1))
			eval "schema=({0..$lastCol})"
			schema=("${schema[@]/#/COL}")
		    fi
		fi
		local end=$((${#schema[@]} - 1))
		local start=0; [ "$isOmitKey" ] && start=1
		eval "queriedColumns=({$start..$end})"
	    fi

	    normalizeSchema
	    for c in "${queriedColumns[@]}"
	    do
		local value="$(unescape "${columns[$c]}x")"
		printf '%s=%q\n' "${normalizedSchema[$c]}" "${value%x}"
	    done
	    ;;
	'') unescape "$line";;
	*)  printf >&2 'ASSERT: Unknown outputFormat: %s\n' "$outputFormat"; exit 2;;
    esac
}

initializeTable()
{
    local IFS=' '; [ ${#schema[@]} -eq 0 ] && schema=($DEFAULT_SCHEMA)
    local IFS=$'\t'
    printf > "$TABLE_FILESPEC" '# %s\n' "${schema[*]}"
}
update()
{
    [ -r "$TABLE_FILESPEC" ] || initializeTable  # Need to write at least one line so that sed does processing; can use that for a descriptive header.

    # Escape newlines and backslashes.
    [ "${line/[$'\n'\\]/}" = "$line" ] || line="$(escapeNewline "$line")"

    local key="${line%%$'\t'*}"
    if [ ! "$key" ]; then
	echo >&2 'ERROR: Key must not be empty.'
	exit 2
    fi
    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that we don't need to append the line at the end.
    # On the last line, we check the hold space, and skip further processing of
    # the line if the hold space isn't empty.
    sed -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/h" \
	-e "/^${literalKeyPattern}\\t/c${line//\\/\\\\}"  \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e "\$a${line//\\/\\\\}" \
	-- "$TABLE_FILESPEC" || return 1
}

delete()
{
    local IFS=$'\t'
    [ -e "$TABLE_FILESPEC" ] || return 1

    local literalKeyPattern="$(printf %s "$key" | literalPattern)"

    # If we find the key, duplicate its line into the hold space; this serves as
    # a marker that a deletion was done.
    # On the last line, we check the hold space, and indicate unsuccessful
    # deletion via a special exit status.
    sed -i \
	"${IGNORE_HEADER_LINE_SED_ARGS[@]}" \
	-e "/^${literalKeyPattern}\\t/{ h; d; }" \
	-e ':skipHeader' \
	-e '${ x; /./{ x; b; }; x; }' \
	-e '$q 4' \
	-- "$TABLE_FILESPEC"
}

drop()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    rm -- "$TABLE_FILESPEC"
}

iterateOverRecords()
{
    local commandLine="${1?}"; shift
    normalizeSchema

    while IFS=$'\t' read -r "$@" "${normalizedSchema[@]}"
    do
	eval "$commandLine"
    done < <(sed -n "${IGNORE_HEADER_LINE_SED_ARGS[@]}" -e p -e ':skipHeader' -- "$TABLE_FILESPEC")
}
each()
{
    [ -e "$TABLE_FILESPEC" ] || return 1

    typeset -a iterateReadArgs=()
    if [ ${#schema[@]} -eq 0 ]; then
	if ! loadSchemaFromTable; then
	    iterateReadArgs=(-a COL)
	fi
    fi

    eval "${beforeCommands[@]}"
	for cl in "${commandLines[@]}"
	do
	    iterateOverRecords "$cl" "${iterateReadArgs[@]}"
	done
    eval "${afterCommands[@]}"
}
queryKeys()
{
    [ -e "$TABLE_FILESPEC" ] || return 1
    schema=(key ignoredColumns)
    iterateOverRecords 'echo $key'
}


typeset -a IGNORE_HEADER_LINE_SED_ARGS=(-e '1{ /^#/b skipHeader }')

readonly CONFIG_DIRSPEC="${XDG_CONFIG_HOME:-$HOME/.config}${namespace:+/}$namespace"
[ -d "$CONFIG_DIRSPEC" ] || mkdir -p -- "$CONFIG_DIRSPEC" || { printf >&2 'ERROR: Could not initialize database store at %s!\n' "$CONFIG_DIRSPEC"; exit 1; }
readonly TABLE_FILESPEC="${CONFIG_DIRSPEC}/$table"

if [ ${#queriedColumns[@]} -gt 0 ]; then
    if ! translateColumnNamesToIndices; then
	if ! loadSchemaFromTable; then
	    printf >&2 'ERROR: Cannot resolve named columns from the table %s, as no schema is defined there. Use indices or pass a --schema SCHEMA.\n' "${namespace}${namespace:+/}${table}"
	    exit 2
	fi
	translateColumnNamesToIndices
    fi
fi

"$action"
